"""This module holds classes and functions to run the EM algorithm."""

__all__ = [
    "EM",
]


import numpy as np

from probability.distributions.gaussian import pdf as multivariate_gaussian_pdf
from tools.data_creation import xnor


class EM:
    """Expectation-maximization algorithm for soft assignment (GMM)."""

    def __init__(self, data: np.ndarray, num_clusters: int):
        """
        Initializes the class and stores the given parameters.
        It is assumed that:
        - each row of data contains a sample.
        - that the number of desired clusters is less (or equal) than the number of samples.

        :param data: Data to fit.
        :param num_clusters: Number of clusters.
        """
        self.eps = 1e-7
        self.data = data
        self.num_clusters = num_clusters
        self.clusters = Clusters(num_clusters=num_clusters)
        self.initialize_clusters()

    def initialize_clusters(self):
        """Initialize the previously created clusters by setting their working parameters to a starting point."""
        n, d = self.data.shape
        sample_indices = np.random.choice(n, self.num_clusters, replace=False)
        initial_strengths = np.random.dirichlet(np.ones(self.num_clusters), size=1).T

        for cluster, sample_index, strength in zip(
            self.clusters, sample_indices, initial_strengths
        ):  # fake e-step
            cluster.strength = np.reshape(strength, (1, 1))
            cluster.mean = np.reshape(self.data[sample_index, :], (d, 1))
            cluster.covariance = np.eye(d) * np.random.random()

    def run(self, iterations: int):
        """
        Run the EM algorithm to the given data.
        :param iterations: Number of iterations to run the EM algorithm.
        """
        for iteration in range(iterations):
            self.e()
            self.m()

    def e(self):
        """Run the expectation part of the algorithm."""
        pdfs = self.clusters.pdfs(self.data)
        strengths = self.clusters.strengths

        for cluster, pdf, strength in zip(self.clusters, pdfs, strengths):
            cluster.membership = np.reshape(
                pdf * strength / (np.sum(strengths * pdfs) + self.eps), (pdf.size, 1)
            )

    def m(self):
        """Run the maximization part of the algorithm."""
        for cluster in self.clusters:
            sum_membership = np.sum(cluster.membership)
            cluster.mean = (
                np.sum(self.data * cluster.membership, axis=0, keepdims=True)
                / (sum_membership + self.eps)
            ).T
            cluster.covariance = (
                (self.data - cluster.mean.T).T
                @ (np.eye(cluster.membership.size) * cluster.membership)
                @ (self.data - cluster.mean.T)
            ) / (sum_membership + self.eps)
            cluster.strength = np.array([[(1 / self.data.shape[0]) * sum_membership]])


class Clusters:
    """A class that creates many Cluster classes."""

    def __init__(self, num_clusters: int):
        """Initialize class by generating a number of Cluster classes."""
        self.num_clusters = num_clusters
        self.clusters = {}
        self.create_clusters()

    def __len__(self) -> int:
        """Magic method to return length of Clusters class."""
        return len(self.clusters)

    def __getitem__(self, index) -> "Cluster":
        """Magic method to return Cluster class when this class is called."""
        try:
            return self.clusters[index]
        except KeyError:
            raise StopIteration

    def create_clusters(self):
        """Creates multiple cluster classes."""
        for index in range(self.num_clusters):
            self.create_cluster(index=index)

    def create_cluster(self, index: int):
        """Create polynom and add it to the dictionary of polynoms."""
        self.clusters[index] = Cluster()

    def pdfs(self, data: np.ndarray, scaled: bool = True):
        """
        Compute probabilites that the given datapoint is generated by each cluster.
        Note that the sum of these probabilities always adds up to 1.
        """
        raw_probabilities = np.array([c.pdf(data) for c in self.clusters.values()])
        if scaled is True:
            return raw_probabilities / np.sum(raw_probabilities, axis=0)
        return raw_probabilities

    @property
    def strengths(self):
        """
        Get strength value of all Clusters
        """
        return np.atleast_2d(np.array([c.strength for c in self.clusters.values()]))

    @property
    def means(self):
        """
        Get mean value of all Clusters
        """
        return np.array([c.mean for c in self.clusters.values()])

    @property
    def covariances(self):
        """
        Get covariance value of all Clusters
        """
        return np.array([c.covariance for c in self.clusters.values()])

    @property
    def memberships(self):
        """
        Get membership value of all Clusters
        """
        return np.array([c.membership for c in self.clusters.values()])


class Cluster:
    """Class representing a single cluster."""

    def __init__(self):
        """
        Initialize the cluster class.
        """
        self.mean = None
        self.covariance = None
        self.strength = None
        self.membership = None

    def pdf(self, data: np.ndarray):
        """Compute PDF of cluster for the given datapoint."""
        return multivariate_gaussian_pdf(X=data, m=self.mean, C=self.covariance)


if __name__ == "__main__":
    """Demo to create XNOR dataset, fit the GMMs via EM algo and show it on plotly."""

    import plotly.graph_objects as go
    from plotly.offline import plot

    n = 100
    X, _ = xnor(n)

    em = EM(data=X, num_clusters=4)
    em.run(iterations=50)

    x = np.linspace(min(X[:, 0]), max(X[:, 0]), n)
    y = np.linspace(min(X[:, 1]), max(X[:, 1]), n)
    z = np.zeros((n, n))
    for i, xi in enumerate(x):
        for j, yi in enumerate(y):
            z[i, j] = max(em.clusters.pdfs(np.array([[xi, yi]]), False))

    d = [{"x": x, "y": y, "z": z, "type": "surface"}]

    layout = go.Layout(scene=dict(aspectmode="cube"))
    figure = go.Figure(data=d, layout=layout)
    plot(figure)
